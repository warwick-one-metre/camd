#!/usr/bin/env python3
#
# This file is part of camd.
#
# camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=no-self-use
# pylint: disable=broad-except

from ctypes import c_float, c_int32, c_int, c_uint16, c_long, byref, create_string_buffer, CDLL
import datetime
import math
from pathlib import Path
import queue
import tempfile
import threading
import time
from astropy.io import fits
import numpy
import Pyro4

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'

PYRO_COMM_TIMEOUT = 5

CAMD_HOST = '192.168.0.101'
CAMD_PORT = 9010
CAMD_NAME = 'cam_daemon'

TELD_HOST = '192.168.0.101'
TELD_PORT = 9003
TELD_NAME = 'telescope_daemon'

VAISALA_HOST = '192.168.0.102'
VAISALA_PORT = 9001
VAISALA_NAME = 'vaisala_daemon'

ROOMALERT_HOST = '192.168.0.102'
ROOMALERT_PORT = 9008
ROOMALERT_NAME = 'roomalert_daemon'

SUPERWASP_HOST = '192.168.0.102'
SUPERWASP_PORT = 9007
SUPERWASP_NAME = 'superwasp_daemon'

TELD_URL = 'PYRO:' + TELD_NAME + '@' + TELD_HOST + ':' + str(TELD_PORT)
VAISALA_URL = 'PYRO:' + VAISALA_NAME + '@' + VAISALA_HOST + ':' + str(VAISALA_PORT)
ROOMALERT_URL = 'PYRO:' + ROOMALERT_NAME + '@' + ROOMALERT_HOST + ':' + str(ROOMALERT_PORT)
SUPERWASP_URL = 'PYRO:' + SUPERWASP_NAME + '@' + SUPERWASP_HOST + ':' + str(SUPERWASP_PORT)

# Delay between camera state queries (in seconds)
STATUS_QUERY_DELAY = 1

# Delay between frame save polls (in seconds)
SAVE_POLL_DELAY = 1

# This should be kept in sync with the dictionary in cam
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

    CameraNotFound = 5

    # Command-specific codes
    CameraNotInitialized = 10
    CameraNotIdle = 11
    CameraNotUninitialized = 14
    CameraNotAcquiring = 15

    TemperatureOutsideLimits = 20
    InvalidHorizontalBinning = 30
    InvalidVerticalBinning = 31
    InvalidReadoutX = 32
    InvalidReadoutY = 33
    InvalidReadoutWidth = 34
    InvalidReadoutHeight = 35
    InvalidGainIndex = 40
    InvalidShiftSpeedIndex = 41

    DirectoryNotWritable = 50

class CameraStatus:
    """Status of the camera hardware"""
    Disabled, Initializing, Idle, Acquiring, Aborting = range(5)

class AndorStatus:
    """Status codes returned by libandor"""
    Success = 20002

    # Temperature status
    TemperatureStabilized = 20036
    TemperatureOff = 20034

    # Setting readout geometry
    DrvP1Invalid = 20066
    DrvP2Invalid = 20067
    DrvP3Invalid = 20068
    DrvP4Invalid = 20069
    DrvP5Invalid = 20076
    DrvP6Invalid = 20077

class TryLock(object):
    """Helper object for use with `with` statements"""
    def __init__(self, lock):
        self._lock = lock
        self._locked = False

    def __enter__(self):
        self._locked = self._lock.acquire(False)
        return self._locked

    def __exit__(self, *args):
        if self._locked:
            self._lock.release()
            self._locked = False

class CameraDaemon:
    """Daemon interface for talon subystems"""
    def __init__(self):
        self._status = CameraStatus.Disabled

        self._driver = None
        self._driver_lock = threading.Lock()

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        # Camera data: loaded during init
        self._camera_model = 'unknown'
        self._camera_serial = 0

        self._temperature = 0
        self._temperature_locked = False
        self._cooler_enabled = False
        self._target_temperature = -30

        # Temperature limits: loaded during init
        self._min_temperature = 0
        self._max_temperature = 0

        # CCD size: loaded during init
        self._ccd_width = 0
        self._ccd_height = 0

        # Readout geometry: defaults loaded during init
        self._geometry_bin_x = 0
        self._geometry_bin_y = 0
        self._geometry_x = 0
        self._geometry_y = 0
        self._geometry_width = 0
        self._geometry_height = 0

        # Shutter enabled (opens during exposures), or remains closed
        self._shutter_enabled = False

        # Gain index. For blue camera: 0 = 1x, 1 = 2x, 2 = 4x
        self._gains = []
        self._gain_index = 0
        self._exposure_time = 1

        # Horizontal shift speeds in MHz: loaded during init
        self._horizontal_shift_speeds = []
        self._horizontal_shift_speed_index = 0

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # Information for building the output filename
        self._output_directory = '/home/saft/src/camd/'
        self._output_frame_prefix = 'object'
        self._output_frame_number = 0

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        # Queue of captured frames waiting to be saved to disk by the status thread
        self._acquisition_queue = queue.Queue()

        # Thread for saving acquired frames to disk
        save_thread = threading.Thread(target=self.__poll_acquired_frames)
        save_thread.daemon = True
        save_thread.start()

        # Thread for polling camera status
        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._driver_lock:
                if self._driver is not None:
                    # Query temperature status
                    temp = c_float()
                    status = self._driver.GetTemperatureF(byref(temp))
                    self._temperature = temp.value
                    self._temperature_locked = status == AndorStatus.TemperatureStabilized
                    self._cooler_enabled = status != AndorStatus.TemperatureOff
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(STATUS_QUERY_DELAY)

    def __poll_acquired_frames(self):
        """Background thread that polls the acquisition queue and saves frames to disk"""
        while True:
            # Save any acquired frames to disk
            while not self._acquisition_queue.empty():
                try:
                    frame = self._acquisition_queue.get()
                    shape = (self._geometry_height // self._geometry_bin_y,
                             self._geometry_width // self._geometry_bin_x)
                    data = numpy.frombuffer(frame[0], dtype=numpy.uint16).reshape(shape)
                    hdu = fits.PrimaryHDU(data)

                    # Build list of header keys
                    header = [
                        (None, None, None),
                        ('COMMENT', ' ---                DATE/TIME                --- ', ''),
                        ('DATE-OBS', frame[1].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                         '[UTC] date that exposure was triggered'),
                        ('DATE-END', frame[2].strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                         '[UTC] date that data was received by PC'),
                        ('EXPTIME', float(self._exposure_time), '[s] exposure time'),
                        ('TIME-SRC', 'NTP', 'times are measured using NTP-synced PC clock'),
                    ]

                    header.extend(self.__telescope_frame_headers())
                    header.extend(self.__camera_frame_headers())
                    header.extend(self.__environment_frame_headers())

                    # Using Card and append() to force comment cards to be placed inline
                    for h in header:
                        hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

                    path = '{}/{}-{:04d}.fits.gz'.format(self._output_directory,
                                                         self._output_frame_prefix,
                                                         self._output_frame_number)

                    hdu.writeto(path, clobber=True)
                    print('save thread: saved frame ' + path)
                    self._output_frame_number += 1
                except Exception as e:
                    print('save thread: swallowing error ' + str(e))
            time.sleep(SAVE_POLL_DELAY)

    def __telescope_frame_headers(self):
        """Returns a dictionary of the telescope-related fits frame headers"""
        h = [
            (None, None, None),
            ('COMMENT', ' ---          TELESCOPE INFORMATION          --- ', ''),
        ]

        try:
            with Pyro4.Proxy(TELD_URL) as teld:
                t = teld.report_status()
                h.append(('TELSWVER', t['software_version'], 'TCS server software version'))
                h.append(('TELSTATE', t['state_label'], 'telescope status'))
                if t['state'] != 0:
                    harad = t['lst'] - t['ra']
                    while harad > math.pi:
                        harad -= 2*math.pi
                    while harad < -math.pi:
                        harad += 2*math.pi

                    ra = sexagesimal(t['ra'] * 12 / math.pi)
                    h.append(('TELRA', ra, 'telescope nominal J2000 RA'))
                    dec = sexagesimal(math.degrees(t['dec']))
                    h.append(('TELDEC', dec, 'telescope nominal J2000 Dec'))
                    ha = sexagesimal(harad * 12 / math.pi)
                    h.append(('TELHA', ha, 'telescope nominal HA'))
                    rad = round(math.degrees(t['ra']), 3)
                    h.append(('TELRAD', rad, '[deg] telescope nominal J2000 RA'))
                    decd = round(math.degrees(t['dec']), 3)
                    h.append(('TELDECD', decd, '[deg] telescope nominal J2000 Dec'))
                    had = round(math.degrees(harad), 3)
                    h.append(('TELHAD', had, '[deg] telescope nominal HA'))
                    altd = round(math.degrees(t['alt']), 3)
                    h.append(('ALTITUDE', altd, '[deg] telescope altitude'))
                    azd = round(math.degrees(t['az']), 3)
                    h.append(('AZIMUTH', azd, '[deg] telescope azimuth'))
                    h.append(('TELFOCUS', t['telescope_focus_um'], '[um] telescope nominal focus'))
        except Exception:
            pass

        return h

    def __camera_frame_headers(self):
        """Returns a dictionary of the camera-related fits frame headers"""
        rspd = self._horizontal_shift_speeds[self._horizontal_shift_speed_index]
        shutter = 'AUTO' if self._shutter_enabled else  'CLOSED'
        return [
            (None, None, None),
            ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
            ('CAMSWVER', SOFTWARE_VERSION, 'camera server software version'),
            ('CAMERA', self._camera_model + ' ({})'.format(self._camera_serial),
             'camera model and serial number'),
            ('CCD-TEMP', round(self._temperature, 2), '[deg c] CCD temperature at end of exposure'),
            ('SET-TEMP', self._target_temperature, '[deg c] CCD temperature set point'),
            ('TEMP-LCK', self._temperature_locked, 'CCD temperature is locked to set point'),
            ('CCD-XBIN', self._geometry_bin_x, '[px] x binning'),
            ('CCD-YBIN', self._geometry_bin_y, '[px] y binning'),
            ('CCD-WIND', '[{}:{},{}:{}]'.format(
                self._geometry_x, self._geometry_x + self._geometry_width - 1,
                self._geometry_y, self._geometry_y + self._geometry_height - 1),
             '[x1:x2,y1:y2] detector readout area'),
            ('CCD-GAIN', self._gains[self._gain_index], '[e-/DN] nominal readout gain'),
            ('CCD-RSPD', rspd, '[MHz] CCD readout speed'),
            ('SHUTTER', shutter, 'shutter mode'),
        ]

    def __environment_frame_headers(self):
        """Returns a dictionary of the environment-related fits frame headers"""
        h = [
            (None, None, None),
            ('COMMENT', ' ---         ENVIRONMENT INFORMATION         --- ', ''),
        ]

        try:
            with Pyro4.Proxy(VAISALA_URL) as vaisala:
                v = vaisala.last_measurement()
                if v is not None:
                    h.append(('VSWVER', v['software_version'], 'vaisala server software version'))
                if v is not None and v['wind_speed_valid']:
                    h.append(('VWINDSPD', v['wind_speed'], '[km/h] vaisala wind speed'))
                if v is not None and v['wind_direction_valid']:
                    h.append(('VWINDDIR', v['wind_direction'], '[deg] vaisala wind direction'))
                if v is not None and v['temperature_valid']:
                    h.append(('VEXTTEMP', v['temperature'], '[deg c] vaisala external temperature'))
                if v is not None and v['relative_humidity_valid']:
                    h.append(('VEXTHUMD', v['relative_humidity'], '[%] vaisala external humidity'))
                if v is not None and v['pressure_valid']:
                    h.append(('VPRESSUR', v['pressure'], '[hPa] vaisala air pressure'))
        except Exception:
            pass
        try:
            with Pyro4.Proxy(ROOMALERT_URL) as roomalert:
                r = roomalert.last_measurement()
                if r is not None:
                    h.append(('RASWVER', r['software_version'],
                              'room alert server software version'))
                    h.append(('DOMETEMP', r['internal_temp'], '[deg c] dome temperature'))
                    h.append(('DOMEHUMD', r['internal_humidity'], '[%] dome humidity'))
                    h.append(('TRUSTEMP', r['truss_temp'], '[deg c] truss temperature'))
        except Exception:
            pass

        try:
            with Pyro4.Proxy(SUPERWASP_URL) as superwasp:
                s = superwasp.last_measurement()
                if s is not None:
                    h.append(('SWSWVER', s['software_version'],
                              'superwasp monitor server software version'))
                    h.append(('SKYTEMP', s['sky_temp'], '[deg c] sky temperature'))
                    h.append(('DEWPDELT', s['dew_point_delta'],
                              '[deg c] temperature above dew point'))
        except Exception:
            pass

        return h

    def __set_target_temperature_and_cooler(self, target_temperature, cooler_enabled):
        """Set the camera temperature and cooler configuration"""
        self._target_temperature = target_temperature
        with self._driver_lock:
            if self._driver is None:
                return False

            status = self._driver.SetTemperature(c_int(target_temperature))
            if status != AndorStatus.Success:
                return False

            if cooler_enabled:
                status = self._driver.CoolerON()
            else:
                status = self._driver.CoolerOFF()

            return status == AndorStatus.Success

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            pixel_count = (self._geometry_width // self._geometry_bin_x) * \
                          (self._geometry_height // self._geometry_bin_y)
            while not self._stop_acquisition:
                framedata = bytearray(pixel_count * 2)

                with self._driver_lock:
                    start_time = datetime.datetime.utcnow()
                    status = self._driver.StartAcquisition()
                if status != AndorStatus.Success:
                    print('exposure sequence: failed to start acquisition with status ' + \
                          str(status))
                    break

                # TODO: thread safety: do we need the driver lock?
                status = self._driver.WaitForAcquisition()
                if status != AndorStatus.Success:
                    print('exposure sequence: waiting failed with status ' + str(status))
                    break

                end_time = datetime.datetime.utcnow()
                cdata = (c_uint16 * pixel_count).from_buffer(framedata)
                status = self._driver.GetAcquiredData16(byref(cdata), c_long(pixel_count))
                if status != AndorStatus.Success:
                    print('exposure sequence: failed to get acquired data with status ' + \
                          str(status))
                    break

                self._sequence_frame_count += 1
                self._acquisition_queue.put((framedata, start_time, end_time))

                # Set exposure count completed
                if self._sequence_frame_limit > 0 and \
                        self._sequence_frame_count >= self._sequence_frame_limit:
                    self._stop_acquisition = True
        finally:
            self._status = CameraStatus.Idle

    @Pyro4.expose
    def set_target_temperature(self, temperature, enable_cooler=None):
        """Set the target camera temperature.  Optionally enable or disable cooling"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if temperature < self._min_temperature or temperature > self._max_temperature:
                return CommandStatus.TemperatureOutsideLimits

            if enable_cooler is None:
                enable_cooler = self.enable_cooler

            if not self.__set_target_temperature_and_cooler(temperature, enable_cooler):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def enable_cooler(self, enabled):
        """Enable or disable active cooling"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if not self.__set_target_temperature_and_cooler(self._target_temperature, enabled):
                return CommandStatus.Failed

            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:
            shift_mhz = self._horizontal_shift_speeds[self._horizontal_shift_speed_index]
            gain_factor = self._gains[self._gain_index]
            next_filename = '{}-{:04d}.fits.gz'.format(self._output_frame_prefix,
                                                       self._output_frame_number)
            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_locked,
                'target_temperature': self._target_temperature,
                'cooler_enabled': self._cooler_enabled,
                'shutter_enabled': self._shutter_enabled,
                'exposure_time': self._exposure_time,
                'gain_index': self._gain_index,
                'gain_factor': gain_factor,
                'horizontal_shift_speed_index': self._horizontal_shift_speed_index,
                'horizontal_shift_speed_mhz': shift_mhz,
                'geometry_bin_x': self._geometry_bin_x,
                'geometry_bin_y': self._geometry_bin_y,
                'geometry_x': self._geometry_x,
                'geometry_y': self._geometry_y,
                'geometry_width': self._geometry_width,
                'geometry_height': self._geometry_height,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
                'frame_directory': self._output_directory,
                'next_filename': next_filename
            })
        return data

    # pylint: disable=too-many-return-statements
    # pylint: disable=too-many-branches
    # pylint: disable=too-many-statements
    # pylint: disable=too-many-locals
    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            print('initializing driver')
            driver = CDLL('libandor.so')
            try:
                num_cameras = c_int32()
                status = driver.GetAvailableCameras(byref(num_cameras))
                if status != AndorStatus.Success or num_cameras.value == 0:
                    return CommandStatus.CameraNotFound

                print('{} cameras available'.format(num_cameras.value))
                print('using first camera')

                handle = c_int32()
                status = driver.GetCameraHandle(c_int32(0), byref(handle))
                if status != AndorStatus.Success:
                    print('failed to query camera handle with status {}'.format(status))
                    return CommandStatus.Failed

                status = driver.SetCurrentCamera(handle)
                if status != AndorStatus.Success:
                    print('failed to set current camera with status {}'.format(status))
                    return CommandStatus.Failed

                status = driver.Initialize('/usr/local/etc/andor'.encode('ascii'))
                if status != AndorStatus.Success:
                    print('failed to initialize camera with status {}'.format(status))
                    return CommandStatus.Failed

                # Query camera model
                model = create_string_buffer(4096)
                status = driver.GetHeadModel(model)
                if status != AndorStatus.Success:
                    print('failed to query camera model with status {}'.format(status))
                    return CommandStatus.Failed

                # Query camera serial number
                serial = c_int(0)
                status = driver.GetCameraSerialNumber(byref(serial))
                if status != AndorStatus.Success:
                    print('failed to query camera serial number with status {}'.format(status))
                    return CommandStatus.Failed

                # Query cooler temperature limits
                min_temp = c_int(self._min_temperature)
                max_temp = c_int(self._max_temperature)
                status = driver.GetTemperatureRange(byref(min_temp), byref(max_temp))
                if status != AndorStatus.Success:
                    print('failed to query camera temperature limits with status ' + str(status))
                    return CommandStatus.Failed

                # Query detector size
                width = c_int(self._ccd_width)
                height = c_int(self._ccd_height)
                status = driver.GetDetector(byref(width), byref(height))
                if status != AndorStatus.Success:
                    print('failed to query detector size with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default shutter
                shutter = c_int(0 if self._shutter_enabled else 2)
                status = driver.SetShutter(c_int(1), shutter, c_int(50), c_int(50))
                if status != AndorStatus.Success:
                    print('failed to set shutter closed with status {}'.format(status))
                    return CommandStatus.Failed

                # Configure standard 2D image readout
                status = driver.SetReadMode(c_int(4))
                if status != AndorStatus.Success:
                    print('failed to set image readout mode with status {}'.format(status))
                    return CommandStatus.Failed

                # Camera does not support hardware timing, so we are forced to do individual
                # exposures via software
                status = driver.SetAcquisitionMode(c_int(1))
                if status != AndorStatus.Success:
                    print('failed to set acquisition mode with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default exposure time
                status = driver.SetExposureTime(c_float(self._exposure_time))
                if status != AndorStatus.Success:
                    print('failed to set default exposure time with status {}'.format(status))
                    return CommandStatus.Failed

                # Query gains
                gain_count = c_int(0)
                status = driver.GetNumberPreAmpGains(byref(gain_count))
                if status != AndorStatus.Success:
                    print('failed to query gain count with status ' + str(status))
                    return CommandStatus.Failed

                gains = []
                gain = c_float(0)
                for i in range(gain_count.value):
                    status = driver.GetPreAmpGain(c_int(i), byref(gain))
                    if status != AndorStatus.Success:
                        print('failed to query gain for index {} with status {}'.format(i, status))
                        return CommandStatus.Failed
                    gains.append(gain.value)

                # Set default gain index
                status = driver.SetPreAmpGain(c_int(self._gain_index))
                if status != AndorStatus.Success:
                    print('failed to set default gain index with status {}'.format(status))
                    return CommandStatus.Failed

                # Query horizontal shift speeds
                # Assumes that there is only one readout channel, and no electron multiplication
                shift_count = c_int(0)
                status = driver.GetNumberHSSpeeds(c_int(0), c_int(0), byref(shift_count))
                if status != AndorStatus.Success:
                    print('failed to query horizontal shift speed count with status ' + \
                          str(status))
                    return CommandStatus.Failed

                speeds = []
                speed = c_float(0)
                for i in range(shift_count.value):
                    status = driver.GetHSSpeed(c_int(0), c_int(0), c_int(i), byref(speed))
                    if status != AndorStatus.Success:
                        print('failed to query horizontal shift speed for index ' + \
                            '{} with status {}'.format(i, status))
                        return CommandStatus.Failed
                    speeds.append(speed.value)

                # Set default horizontal shift index
                status = driver.SetHSSpeed(c_int(self._horizontal_shift_speed_index))
                if status != AndorStatus.Success:
                    print('failed to set default horizontal shift speed index with status ' + \
                          str(status))
                    return CommandStatus.Failed

                # Set default readout geometry
                status = driver.SetImage(c_int(1), c_int(1),
                                         c_int(1), c_int(width.value),
                                         c_int(1), c_int(height.value))
                if status != AndorStatus.Success:
                    print('failed to set default readout geometry with status {}'.format(status))
                    return CommandStatus.Failed

                with self._driver_lock:
                    self._driver = driver
                    self._camera_model = model.value.decode('ascii')
                    self._camera_serial = serial.value
                    self._min_temperature = min_temp.value
                    self._max_temperature = max_temp.value
                    self._ccd_width = width.value
                    self._ccd_height = height.value
                    self._geometry_bin_x = 1
                    self._geometry_bin_y = 1
                    self._geometry_x = 1
                    self._geometry_y = 1
                    self._geometry_width = self._ccd_width
                    self._geometry_height = self._ccd_height
                    self._gains = gains
                    self._horizontal_shift_speeds = speeds
                    self._status = CameraStatus.Idle

                return CommandStatus.Succeeded
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    driver.ShutDown()
                    self._status = CameraStatus.Disabled
    # pylint: enable=too-many-return-statements
    # pylint: enable=too-many-branches
    # pylint: enable=too-many-statements
    # pylint: enable=too-many-locals

    @Pyro4.expose
    def set_output_frame_directory(self, directory):
        """Sets the output frame directory"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled

            # Check that the directory exists and is writable
            try:
                path = str(Path(directory).resolve())
                testfile = tempfile.TemporaryFile(dir=path)
                self._output_directory = path
                testfile.close()
            except Exception:
                return CommandStatus.DirectoryNotWritable
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_output_frame_prefix(self, prefix):
        """Sets the output frame prefix"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled
            self._output_frame_prefix = prefix

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_output_frame_number(self, number):
        """Sets the output frame number"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled
            self._output_frame_number = int(number)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled):
        """Enable or disable the shutter"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                value = c_int(0 if enabled else 2)
                status = self._driver.SetShutter(c_int(1), value, c_int(50), c_int(50))
                if status != AndorStatus.Success:
                    mode = 'auto' if enabled else 'closed'
                    print('failed to set shutter {} with status {}'.format(mode, status))
                    return CommandStatus.Failed
                self._shutter_enabled = enabled

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_gain(self, gain_index):
        """Set the preamplifier gain index"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetPreAmpGain(c_int(gain_index))
                if status == AndorStatus.DrvP1Invalid:
                    return CommandStatus.InvalidGainIndex
                if status != AndorStatus.Success:
                    print('failed to set gain {} with status {}'.format(gain_index, status))
                    return CommandStatus.Failed
                self._gain_index = gain_index

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_horizontal_shift(self, shift_speed_index):
        """Set the horizontal shift speed index"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetHSSpeed(c_int(0), c_int(shift_speed_index))
                if status == AndorStatus.DrvP2Invalid:
                    return CommandStatus.InvalidShiftSpeedIndex
                if status != AndorStatus.Success:
                    print('failed to set horizontal shift {} with status {}'.format(
                        shift_speed_index, status))
                    return CommandStatus.Failed
                self._horizontal_shift_speed_index = shift_speed_index

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds):
        """Set the exposure time in seconds"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetExposureTime(c_float(seconds))
                if status != AndorStatus.Success:
                    print('failed to set exposure ({}s) with status {}'.format(seconds, status))
                    return CommandStatus.Failed
                self._exposure_time = seconds

            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_geometry(self, bin_x, bin_y, x, y, width, height):
        """Set the exposure readout geometry.
           Geometry is defined in the binned coordinate system."""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetImage(c_int(bin_x), c_int(bin_y),
                                               c_int(x), c_int(x + width - 1),
                                               c_int(y), c_int(y + height - 1))
                if status == AndorStatus.DrvP1Invalid:
                    return CommandStatus.InvalidHorizontalBinning
                elif status == AndorStatus.DrvP2Invalid:
                    return CommandStatus.InvalidVerticalBinning
                elif status == AndorStatus.DrvP3Invalid:
                    return CommandStatus.InvalidReadoutX
                elif status == AndorStatus.DrvP4Invalid:
                    return CommandStatus.InvalidReadoutWidth
                elif status == AndorStatus.DrvP5Invalid:
                    return CommandStatus.InvalidReadoutY
                elif status == AndorStatus.DrvP6Invalid:
                    return CommandStatus.InvalidReadoutHeight
                elif status != AndorStatus.Success:
                    print('failed to set geometry [{},{}]({}, {}, {}, {}) with status {}'.format(
                        bin_x, bin_y, x, y, width, height, status))
                    return CommandStatus.Failed

                self._geometry_bin_x = bin_x
                self._geometry_bin_y = bin_y
                self._geometry_x = x
                self._geometry_y = y
                self._geometry_width = width
                self._geometry_height = height

            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                with self._driver_lock:
                    self._driver.AbortAcquisition()

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

            with self._driver_lock:
                print('shutdown: disconnecting driver')
                self._driver.ShutDown()
                self._driver = None

            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        if self._status != CameraStatus.Acquiring:
            return CommandStatus.CameraNotAcquiring

        self._status = CameraStatus.Aborting
        print('aborting exposure sequence')
        with self._driver_lock:
            self._driver.AbortAcquisition()

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        return CommandStatus.Succeeded

def sexagesimal(angle):
    """Formats a decimal number in sexagesimal format"""
    negative = angle < 0
    angle = math.fabs(angle)

    degrees = int(angle)
    angle = (angle - degrees) * 60
    minutes = int(angle)
    seconds = (angle - minutes) * 60

    if negative:
        degrees *= -1

    return '{:d}:{:02d}:{:05.2f}'.format(degrees, minutes, seconds)

def spawn_daemon():
    """Spawns the daemon and registers it with Pyro"""
    Pyro4.config.COMMTIMEOUT = PYRO_COMM_TIMEOUT
    Pyro4.config.REQUIRE_EXPOSE = True

    pyro = Pyro4.Daemon(host=CAMD_HOST, port=CAMD_PORT)
    camera = CameraDaemon()
    uri = pyro.register(camera, objectId=CAMD_NAME)

    print('Starting camera daemon with Pyro ID:', uri)
    pyro.requestLoop()
    print('Stopping camera daemon with Pyro ID:', uri)

if __name__ == '__main__':
    spawn_daemon()

#!/usr/bin/env python3.6
#
# This file is part of camd.
#
# camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=too-many-instance-attributes
# pylint: disable=too-many-return-statements
# pylint: disable=too-many-branches

import argparse
import datetime
import json
import pathlib
import shutil
import sys
import threading
import time
import traceback
from astropy.io import fits
import numpy as np
import Pyro4
from warwick.observatory.common import (
    daemons,
    log,
    IP,
    TryLock)
from warwick.observatory.common.helpers import pyro_client_matches
from warwick.w1m.camera import CommandStatus, CameraStatus, atcore

# Set automatically when generating RPM package
SOFTWARE_VERSION = "UNKNOWN"

CONFIG = {
    'rasa': {
        'daemon': daemons.rasa_camera,
        'serial': 'CSC-00246',
        'temperature': -25,
        'gainindex': 0,
        'exposure': 1,
        'horizontalshiftindex': 2,
        'delay': 0,
        'overscan': (0, 0),
        'logtable': 'cmos_camd',
        'arm': 'RASA',
        'filter': '',
        'outputpath': '/var/tmp/',
        'outputprefix': 'cmos',
        'expcountlog': '/var/tmp/cmos-counter.json',
        'controlips': [IP.RASAMain]
    }
}

# If frames are being generated faster than the pipeline can handle
# then we block the next frame until it is ready.
# If it blocks for longer than this interval (in seconds) give up and cancel the sequence
PIPELINE_HANDOVER_TIMEOUT = 10

# Delay between camera state queries (in seconds)
STATUS_QUERY_DELAY = 1

class CameraDaemon:
    """Daemon interface for andor camera"""
    def __init__(self, config):
        self._config = config
        self._status = CameraStatus.Disabled
        self._status_lock = threading.Lock()
        self._log_table = config['logtable']
        self._arm_name = config['arm']
        self._filter_name = config['filter']
        self._control_ips = config['controlips']

        self._sdk = atcore.ATCore()
        self._handle = None

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        self._camera_serial = config['serial']
        self._camera_model = 'unknown'

        self._temperature = 0
        self._temperature_status = None
        self._target_temperature = config['temperature']

        # Temperature limits: loaded during init
        self._min_temperature = 0
        self._max_temperature = 0

        # CCD size: loaded during init
        self._ccd_width = 0
        self._ccd_height = 0

        self._exposure_time = config['exposure']
        self._exposure_delay = config['delay']

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # If non-None, time that the last pre-exposure delay was started
        self._sequence_exposure_delay_start_time = None

        # Time that the latest frame in the exposure was started
        self._sequence_exposure_start_time = datetime.datetime.utcnow()

        # Information for building the output filename
        self._output_directory = pathlib.Path(config['outputpath'])
        self._output_frame_prefix = config['outputprefix']

        # Persistent frame counters
        self._counter_filename = config['expcountlog']
        try:
            with open(self._counter_filename, 'r') as infile:
                data = json.load(infile)
                self._exposure_count = data['exposure_count']
                self._exposure_count_reference = data['exposure_reference']
        except Exception:
            now = datetime.datetime.utcnow().strftime('%Y-%m-%d')
            self._exposure_count = 0
            self._exposure_count_reference = now

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        # Condition to support cancellation of the pre-exposure delay
        self._exposure_delay_condition = threading.Condition()

        # Thread for polling camera status
        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._status_lock:
                if self._handle is not None:
                    # Query temperature status
                    self._temperature = self._sdk.get_float(self._handle, "SensorTemperature")
                    self._temperature_status = self._sdk.get_enum_string(self._handle, "TemperatureStatus")
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(STATUS_QUERY_DELAY)

    def __set_target_temperature_and_cooler(self, target_temperature, cooler_enabled):
        """Set the camera temperature and cooler configuration
           Returns an AndorStatus return code
        """
        # TODO
        return CommandStatus.Failed

    def __set_exposure_time(self, exposure_seconds):
        """Sets the given exposure time in seconds
           Returns an AndorStatus return code
        """
        try:
            self._sdk.set_float(self._handle, "ExposureTime", exposure_seconds)
            self._exposure_time = exposure_seconds
            return True
        except Exception:
            traceback.print_exc(file=sys.stdout)
        return False

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            while not self._stop_acquisition:

                # Delay before starting exposures
                if self._exposure_delay > 0:
                    self._sequence_exposure_delay_start_time = datetime.datetime.utcnow()
                    with self._exposure_delay_condition:
                        self._exposure_delay_condition.wait(self._exposure_delay)

                    self._sequence_exposure_delay_start_time = None
                    if self._stop_acquisition:
                        break

                image_bytes = self._sdk.get_int(self._handle, "ImageSizeBytes")
                raw_buffer = np.empty((image_bytes,), dtype='B')

                print('image bytes', image_bytes)
                print('Exposure time', self._sdk.get_float(self._handle, 'ExposureTime'))
                print('FrameRate', self._sdk.get_float(self._handle, 'FrameRate'))
                print('TriggerMode', self._sdk.get_enum_string(self._handle, 'TriggerMode'))

                try:
                    self._sdk.queue_buffer(self._handle, raw_buffer.ctypes.data, image_bytes)

                    start_time = datetime.datetime.utcnow()
                    self._sdk.command(self._handle, "AcquisitionStart")
                except Exception:
                    traceback.print_exc(file=sys.stdout)
                    log.error(self._log_table, 'Failed to start exposure sequence')
                    break

                self._sequence_exposure_start_time = start_time


                try:
                    self._sdk.wait_buffer(self._handle)
                    end_time = datetime.datetime.utcnow()
                except Exception:
                    traceback.print_exc(file=sys.stdout)
                    log.error(self._log_table, 'Failed to wait for exposure to complete')
                    break

                config = {
                    'aoiheight': self._sdk.get_int(self._handle, "AOIHeight"),
                    'aoiwidth': self._sdk.get_int(self._handle, "AOIWidth"),
                    'aoistride': self._sdk.get_int(self._handle, "AOIStride"),
                    'pixelencoding': self._sdk.get_enum_string(self._handle, "PixelEncoding")
                }

                np_arr = raw_buffer[0:config['aoiheight'] * config['aoistride']]
                np_d = np_arr.view(dtype='H')
                np_d = np_d.reshape(config['aoiheight'], round(np_d.size / config['aoiheight']))
                data = np_d[0:config['aoiheight'], 0:config['aoiwidth']]

                self._exposure_count += 1

                # Save updated counts to disk
                with open(self._counter_filename, 'w') as outfile:
                    json.dump({
                        'exposure_count': self._exposure_count,
                        'exposure_reference': self._exposure_count_reference,
                    }, outfile)

                # Build metadata list
                header = [
                    (None, None, None),
                    ('COMMENT', ' ---                DATE/TIME                --- ', ''),
                    ('DATE-OBS', start_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                     '[UTC] date that exposure was triggered'),
                    ('DATE-END', end_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                     '[UTC] date that data was received by PC'),
                    ('EXPTIME', float(self._exposure_time), '[s] exposure time'),
                    ('TIME-SRC', 'NTP', 'times are measured using NTP-synced PC clock'),
                    (None, None, None),
                    ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
                    ('CAMSWVER', SOFTWARE_VERSION, 'camera server software version'),
                    ('CAMERA', self._camera_model + ' ({})'.format(self._camera_serial),
                     'camera model and serial number'),
                    ('INSTRARM', self._arm_name, 'red or blue arm of the instrument'),
                    ('FILTER', self._filter_name, 'filter installed in instrument arm'),
                    ('CCD-TEMP', round(self._temperature, 2),
                     '[deg c] CCD temperature at end of exposure'),
                    ('TEMP-LCK', self._temperature_status  == 'Stabilised',
                     'CCD temperature is locked to set point'),
                    ('SET-TEMP', self._target_temperature, '[deg c] CCD temperature set point'),
                    ('TEMP-ST', self._temperature_status,
                     'CCD temperature is locked to set point'),
                    ('CCD-XBIN', 1, '[px] x binning'),
                    ('CCD-YBIN', 1, '[px] y binning'),
                    ('CCD-WIND', '[{}:{},{}:{}]'.format(
                     1, self._ccd_width+1,
                     1, self._ccd_height+1),
                     '[x1:x2,y1:y2] ccd window (detector coords)'),
                    ('SHUTTER', 'AUTO', 'shutter mode'),
                    ('IMAG-RGN', '[1:{},1:{}]'.format(self._ccd_width+1, self._ccd_height+1),
                     '[x1:x2,y1:y2] image region (image coords)'),
                    ('EXPCNT', self._exposure_count, 'running exposure count since EXPCREF'),
                    ('EXPCREF', self._exposure_count_reference,
                     'date the exposure counter was reset'),
                ]

                hdu = fits.PrimaryHDU(data)

                # Using Card and append() to force comment cards to be placed inline
                for h in header:
                    hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

                # Save errors shouldn't interfere with preview updates, so we use a separate
                # try/catch
                try:
                    filename = self._output_frame_prefix + \
                               '-{:08d}.fits'.format(self._exposure_count)
                    path = str(self._output_directory / filename)

                    # Simulate an atomic write by writing to a temporary file then renaming
                    hdu.writeto(path + '.tmp', overwrite=True)
                    shutil.move(path + '.tmp', path)
                    print('Saving temporary frame: ' + filename)

                except Exception as e:
                    self._stop_acquisition = True
                    print('Failed to save temporary frame: ' + str(e))
                    log.error(self._log_table, 'Failed to save temporary frame (' \
                                          + str(e) + ')')

                # Hand frame over to the pipeline
                # This may block if the pipeline is busy
                try:
                    with daemons.rasa_pipeline.connect(PIPELINE_HANDOVER_TIMEOUT) as pipeline:
                        print('notifying', self._arm_name, path)
                        pipeline.notify_frame(self._arm_name, path)
                except Exception as e:
                    self._stop_acquisition = True
                    print('Failed to hand frame to pipeline: ' + str(e))
                    log.error(self._log_table, 'Failed to hand frame to pipeline (' + str(e) + ')')

                # Continue exposure sequence?
                self._sequence_frame_count += 1
                if 0 < self._sequence_frame_limit <= self._sequence_frame_count:
                    self._stop_acquisition = True
        finally:
            print('exposure sequence: complete')
            log.info(self._log_table, 'Exposure sequence complete')
            self._status = CameraStatus.Idle

    @Pyro4.expose
    def set_target_temperature(self, temperature, enable_cooler=None):
        """Set the target camera temperature.  Optionally enable or disable cooling"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        # TODO
        return CommandStatus.Failed

    @Pyro4.expose
    def enable_cooler(self, enabled):
        """Enable or disable active cooling"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        # TODO
        return CommandStatus.Failed

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:

            # Estimate the current frame progress based on the time delta
            exposure_progress = 0
            delay_progress = 0
            if self._status == CameraStatus.Acquiring:
                if self._sequence_exposure_delay_start_time:
                    data['state'] = CameraStatus.Waiting
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_delay_start_time
                    delay_progress = delta.total_seconds()
                else:
                    delta = datetime.datetime.utcnow() - self._sequence_exposure_start_time
                    exposure_progress = delta.total_seconds()
                    if exposure_progress > self._exposure_time:
                        data['state'] = CameraStatus.Reading
                        exposure_progress = 0

            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_status == 'Stabilised',
                'temperature_status': self._temperature_status,
                'target_temperature': self._target_temperature,
                'shutter_enabled': True,
                'window': [
                    0, self._ccd_width,
                    0, self._ccd_height,
                ],
                'exposure_time': self._exposure_time,
                'exposure_progress': exposure_progress,
                'delay_time': self._sequence_exposure_delay_start_time,
                'delay_progress': delay_progress,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
            })
        return data

    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            try:
                num_cameras = self._sdk.get_int(self._sdk.AT_HNDL_SYSTEM, "DeviceCount")
                if num_cameras == 0:
                    return CommandStatus.CameraNotFound

                found = False
                print('{} cameras available'.format(num_cameras))
                for i in range(num_cameras):
                    handle = self._sdk.open(i)
                    model = self._sdk.get_string(handle, "CameraModel")
                    serial = self._sdk.get_string(handle, "SerialNumber")

                    print('camera {} is {} ({})'.format(i, model, serial))
                    if serial == self._camera_serial:
                        found = True
                        break
                    else:
                        self._sdk.close(handle)

                if not found:
                    print('camera with serial {} was not found'.format(self._camera_serial))
                    return CommandStatus.CameraNotFound

                # Query detector size
                width = self._sdk.get_int(handle, 'SensorWidth')
                height = self._sdk.get_int(handle, 'SensorHeight')

                # Configure standard 2D image readout
                print('TriggerMode', self._sdk.get_enum_string(handle, 'TriggerMode'))

                self._sdk.set_enum_string(handle, 'PixelEncoding', 'Mono16')
                self._sdk.set_enum_string(handle, 'AOIBinning', '1x1')
                self._sdk.set_enum_string(handle, 'TriggerMode', 'Internal')
                self._sdk.set_enum_string(handle, 'CycleMode', 'Fixed')
                self._sdk.set_int(handle, 'FrameCount', 1)
                self._sdk.set_float(handle, 'ExposureTime', self._exposure_time)
                self._sdk.set_enum_string(handle, 'GainMode', 'High dynamic range (16-bit)')
                self._sdk.set_enum_string(handle, 'TemperatureControl', '-25.0')
                self._sdk.set_bool(handle, 'SensorCooling', True)

                with self._status_lock:
                    self._handle = handle
                    self._camera_model = model
                    self._ccd_width = width
                    self._ccd_height = height

                    self._status = CameraStatus.Idle
                    print('camera {} ({}) initalized'.format(self._camera_model,
                                                             self._camera_serial))

                return CommandStatus.Succeeded
            except Exception:
                traceback.print_exc(file=sys.stdout)
                return CommandStatus.Failed
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    if handle:
                        self._sdk.close(handle)
                    self._status = CameraStatus.Disabled
                    log.error(self._log_table, 'Failed to initialize camera')
                else:
                    log.info(self._log_table, 'Initialized camera')

    @Pyro4.expose
    def configure(self, params, quiet=False):
        """Set camera configuration to the requested state
           params should be a dictionary with the following keys:
              temperature: Temperature set point
              cooler: Enable the cooler (True/False)
              shutter: Enable the shutter (True/False)
              gainindex: Gain index
              readoutindex: Readout index
              delay: Pre-exposure delay in seconds
              exposure: Exposure time in seconds
              window: Tuple of (binx, biny, x, y, width, height)
           Any properties not specified in params will be reset to its default

           The params dictionary should be validated using the
           schema returned by the configure_validation_schema helper
        """
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            # Reset cooling
            #temperature = params.get('temperature', self._config['temperature'])
            #cooler = params.get('cooler', True)
            #if self.__set_target_temperature_and_cooler(temperature, cooler) != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Target temperature set to ' + str(temperature))
            #log.info(self._log_table, 'Cooler ' + ('enabled' if cooler else 'disabled'))

            # Reset shutter
            #shutter = params.get('shutter', False)
            #if self.__set_shutter(shutter) != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Shutter set to ' + ('auto' if shutter else 'closed'))

            # Reset gain
            #gain_index = params.get('gainindex', self._config['gainindex'])
            #gain_status = self.__set_gain_index(gain_index)
            #if gain_status == AndorStatus.DrvP1Invalid:
            #    return CommandStatus.InvalidGainIndex
            #if gain_status != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Gain index set to ' +  str(gain_index))

            # Reset readout speed
            #shift_speed_index = params.get('readoutindex', self._config['horizontalshiftindex'])
            #readout_status = self.__set_horizontal_shift_index(shift_speed_index)
            #if readout_status == AndorStatus.DrvP2Invalid:
            #    return CommandStatus.InvalidShiftSpeedIndex
            #if readout_status != AndorStatus.Success:
            #    return CommandStatus.Failed

            #log.info(self._log_table, 'Readout speed index set to ' +  str(shift_speed_index))

            # Reset exposure delay
            self._exposure_delay = params.get('delay', self._config['delay'])

            log.info(self._log_table, 'Exposure delay set to {:.3f}s'.format(self._exposure_delay))

            # Reset exposure time
            exposure = params.get('exposure', self._config['exposure'])
            if not self.__set_exposure_time(exposure):
                return CommandStatus.Failed

            log.info(self._log_table, 'Exposure time set to {:.3f}s'.format(exposure))

            # Reset readout geometry
            #w = params.get('window', (1, 1, 1, 1, self._ccd_width, self._ccd_height))
            #if len(w) != 6:
            #    return CommandStatus.InvalidWindow

            #if not self.__set_ccd_geometry(w[0], w[1], w[2], w[3], w[4], w[5]):
            #    return CommandStatus.InvalidWindow

            #log.info(self._log_table, 'Binning set to {}x{}'.format(w[0], w[1]))
            #log.info(self._log_table, 'Window set to [{}:{},{}:{}]'.format(w[2], w[4], w[3], w[5]))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds, quiet=False):
        """Set the exposure time in seconds"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_exposure_time(seconds):
                return CommandStatus.Failed

            log.info(self._log_table, 'Exposure time set to {:.3f}s'.format(seconds))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure_delay(self, seconds, quiet=False):
        """Set the pre-exposure delay in seconds"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            self._exposure_delay = seconds

            log.info(self._log_table, 'Exposure delay set to {:.3f}s'.format(seconds))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_binning(self, bin_x, bin_y, quiet=False):
        """Sets the CCD readout binning (both x and y)"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            return CommandStatus.Failed

    @Pyro4.expose
    def set_window(self, x, y, width, height, quiet=False):
        """Sets the CCD readout window in unbinned (hardware) pixels"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if x < 1 or y < 1 or x + width - 1 > self._ccd_width or \
                    y + height - 1 > self._ccd_height:
                return CommandStatus.WindowOutsideCCD

            return CommandStatus.Failed

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                self._sdk.command(self._handle, "AcquisitionStop")

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

                print('shutdown: disconnecting camera')
                if self._handle:
                    self._sdk.close(self._handle)

            log.info(self._log_table, 'Shutdown camera')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count, quiet=False):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            count_msg = 'until stopped'
            if count == 1:
                count_msg = '1 frame'
            elif count > 1:
                count_msg = str(count) + ' frames'

            log.info(self._log_table, 'Starting exposure sequence (' + count_msg + ')')
            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if not pyro_client_matches(self._control_ips):
            return CommandStatus.InvalidControlIP

        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        # Note that the Waiting and Reading statuses are artificial
        # self._status stays as CameraStatus.Acquiring during both of these
        if self._status != CameraStatus.Acquiring:
            return CommandStatus.CameraNotAcquiring

        self._status = CameraStatus.Aborting
        print('aborting exposure sequence')
        log.info(self._log_table, 'Aborting exposure sequence')
        self._sdk.command(self._handle, "AcquisitionStop")

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        with self._exposure_delay_condition:
            self._exposure_delay_condition.notify_all()

        return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled, quiet=False):
        """Enable or disable the shutter"""
        return CommandStatus.Succeeded

if __name__ == '__main__':
    description = 'Camera control daemon'
    parser = argparse.ArgumentParser(description=description)
    parser.add_argument('camera', choices=CONFIG.keys(), help='Select a camera')
    args = parser.parse_args()
    cam_config = CONFIG[args.camera]
    cam_config['daemon'].launch(CameraDaemon(cam_config))

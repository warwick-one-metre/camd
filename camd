#!/usr/bin/env python3
#
# This file is part of camd.
#
# camd is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# camd is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with camd.  If not, see <http://www.gnu.org/licenses/>.

"""Daemon for controlling the Warwick one-metre telescope cameras via Pyro"""

# pylint: disable=invalid-name
# pylint: disable=too-many-return-statements
# pylint: disable=too-few-public-methods
# pylint: disable=too-many-instance-attributes
# pylint: disable=no-self-use
# pylint: disable=broad-except
# pylint: disable=too-many-lines

from ctypes import c_float, c_int32, c_int, c_uint16, c_long, byref, create_string_buffer, CDLL
import datetime
import math
import pathlib
import shutil
import queue
import tempfile
import threading
import time
from astropy.io import fits
import numpy
import pyds9
import Pyro4
import warwick.observatory as observatory
import warwick.observatory.helpers as helpers
from warwick.observatory import TryLock

# Set automatically when generating RPM package
SOFTWARE_VERSION = 'UNKNOWN'
INSTRUMENT_ARM = 'BLUE'

if INSTRUMENT_ARM == 'RED':
    DEFAULT_TEMPERATURE = -60
    CAMERA_SERIAL = 12723
    CAMD_DAEMON = observatory.daemons.onemetre_red_camera
    LOG_TABLE = 'redd'
    PRESCAN_COLUMNS = 20
    POSTSCAN_COLUMNS = 20
    ARM_FILTER = 'Z'
else:
    DEFAULT_TEMPERATURE = -30
    CAMERA_SERIAL = 11575
    LOG_TABLE = 'blued'
    CAMD_DAEMON = observatory.daemons.onemetre_blue_camera
    PRESCAN_COLUMNS = 0
    POSTSCAN_COLUMNS = 0
    ARM_FILTER = 'BG40'

DEFAULT_OUTPUT_PATH = '/home/saft/OBS_DATA'
DEFAULT_FRAME_PREFIX = 'junk'
DEFAULT_EXPOSURE_TIME = 1.0
DEFAULT_GAIN_INDEX = 0
DEFAULT_HORIZONTAL_SHIFT_INDEX = 2

LATEST_FRAME_PATH = '/var/tmp/latest-'+INSTRUMENT_ARM+'.fits'
LATEST_FRAME_TEMP_PATH = '/var/tmp/_latest-'+INSTRUMENT_ARM+'.fits'

# Metadata daemons are expected to be well behaved, so a very short timeout is used
# to avoid stalling the frame saving process (missing metadata is preferrable to being late)
PYRO_COMM_TIMEOUT = 1

# Delay between camera state queries (in seconds)
STATUS_QUERY_DELAY = 1

# This should be kept in sync with the dictionary in cam
class CommandStatus:
    """Numeric return codes"""
    # General error codes
    Succeeded = 0
    Failed = 1
    Blocked = 2

    CameraNotFound = 5

    # Command-specific codes
    CameraNotInitialized = 10
    CameraNotIdle = 11
    CameraNotUninitialized = 14
    CameraNotAcquiring = 15

    TemperatureOutsideLimits = 20
    BinningIncompatibleWithWindow = 30
    WindowIncompatibleWithBinning = 31
    WindowOutsideCCD = 32

    InvalidGainIndex = 40
    InvalidShiftSpeedIndex = 41

    DirectoryNotWritable = 50

class CameraStatus:
    """Status of the camera hardware"""
    # Note that the Reading status is assumed at status-query time
    # and is never assigned to CameraDaemon._status
    Disabled, Initializing, Idle, Acquiring, Reading, Aborting = range(6)

class AndorStatus:
    """Status codes returned by libandor"""
    Success = 20002

    # Temperature status
    TemperatureStabilized = 20036
    TemperatureOff = 20034

    # Setting readout geometry
    DrvP1Invalid = 20066
    DrvP2Invalid = 20067
    DrvP3Invalid = 20068
    DrvP4Invalid = 20069
    DrvP5Invalid = 20076
    DrvP6Invalid = 20077

class CameraDaemon:
    """Daemon interface for andor camera"""
    def __init__(self, log_table):
        self._status = CameraStatus.Disabled
        self._log_table = log_table

        self._driver = None
        self._driver_lock = threading.Lock()

        self._status_condition = threading.Condition()
        self._command_lock = threading.Lock()

        # Camera data: loaded during init
        self._camera_model = 'unknown'
        self._camera_serial = 0

        self._temperature = 0
        self._temperature_locked = False
        self._cooler_enabled = False
        self._target_temperature = DEFAULT_TEMPERATURE

        # Temperature limits: loaded during init
        self._min_temperature = 0
        self._max_temperature = 0

        # CCD size: loaded during init
        self._ccd_width = 0
        self._ccd_height = 0

        # Readout geometry: defaults loaded during init
        self._geometry_bin_x = 0
        self._geometry_bin_y = 0
        self._geometry_x = 0
        self._geometry_y = 0
        self._geometry_width = 0
        self._geometry_height = 0

        # Image geometry: masking away the overscan on the red camera
        self._geometry_image_x1 = 0
        self._geometry_image_x2 = 0
        self._geometry_image_y1 = 0
        self._geometry_image_y2 = 0

        # Shutter enabled (opens during exposures), or remains closed
        self._shutter_enabled = False

        # Gain index. For blue camera: 0 = 1x, 1 = 2x, 2 = 4x
        self._gains = []
        self._gain_index = DEFAULT_GAIN_INDEX
        self._exposure_time = DEFAULT_EXPOSURE_TIME

        # Horizontal shift speeds in MHz: loaded during init
        self._horizontal_shift_speeds = []
        self._horizontal_shift_speed_index = DEFAULT_HORIZONTAL_SHIFT_INDEX

        # Limit and number of frames acquired during the next sequence
        # Set to 0 to run continuously
        self._sequence_frame_limit = 0

        # Number of frames acquired this sequence
        self._sequence_frame_count = 0

        # Time that the latest frame in the exposure was started
        self._sequence_exposure_start_time = datetime.datetime.utcnow()

        # Information for building the output filename
        self._output_directory = pathlib.Path(DEFAULT_OUTPUT_PATH)
        self._output_frame_prefix = DEFAULT_FRAME_PREFIX
        self._output_frame_number = 0

        self._output_save_to_disk = False

        self._ds9_preview_addresses = []

        # Thread that runs the exposure sequence
        # Initialized by start() method
        self._acquisition_thread = None

        # Queue and condition for passing data from acquisition thread to processing thread
        self._acquisition_queue = queue.Queue()
        self._acquisition_condition = threading.Condition()
        self._preview_lock = threading.Lock()

        # Signal that the exposure sequence should be terminated
        # at end of the current frame
        self._stop_acquisition = False

        # Thread for saving acquired frames to disk
        process_thread = threading.Thread(target=self.__process_acquired_frames)
        process_thread.daemon = True
        process_thread.start()

        # Thread for polling camera status
        status_thread = threading.Thread(target=self.__poll_camera_status)
        status_thread.daemon = True
        status_thread.start()

    def __poll_camera_status(self):
        """Background thread that polls the camera status"""
        while True:
            # Query temperature
            with self._driver_lock:
                if self._driver is not None:
                    # Query temperature status
                    temp = c_float()
                    status = self._driver.GetTemperatureF(byref(temp))
                    self._temperature = temp.value
                    self._temperature_locked = status == AndorStatus.TemperatureStabilized
                    self._cooler_enabled = status != AndorStatus.TemperatureOff
                else:
                    self._status = CameraStatus.Disabled

            time.sleep(STATUS_QUERY_DELAY)

    def __process_acquired_frames(self):
        """Background thread that saves acquired frames, invokes autoguider, and updates previews"""
        while True:
            # Block until a frame is available for processing
            with self._acquisition_condition:
                self._acquisition_condition.wait()

            while not self._acquisition_queue.empty():
                # Frames are saved in multple stages:
                #  1) The last acquired frame is always saved as /var/tmp/latest-<camera>.fits
                #  2) The pipeline daemon is notified that the latest frame has been updated
                #  3) If saving is enabled the frame is then saved using the defined settings
                #  4) If saving is enabled the pipeline daemon is notified that a new frame is saved
                #  5) Any registered preview clients are updated
                try:
                    frame = self._acquisition_queue.get()
                    shape = (self._geometry_height // self._geometry_bin_y,
                             self._geometry_width // self._geometry_bin_x)
                    data = numpy.frombuffer(frame[0], dtype=numpy.uint16).reshape(shape)
                    hdu = fits.PrimaryHDU(data)

                    # Using Card and append() to force comment cards to be placed inline
                    for h in frame[1]:
                        hdu.header.append(fits.Card(h[0], h[1], h[2]), end=True)

                    # Save errors shouldn't interfere with preview updates, so we use a separate
                    # try/catch
                    try:
                        # Mimic an atomic save by writing to a temporary file and then moving
                        hdu.writeto(LATEST_FRAME_TEMP_PATH, clobber=True)
                        shutil.move(LATEST_FRAME_TEMP_PATH, LATEST_FRAME_PATH)
                        try:
                            pipeline = observatory.daemons.onemetre_pipeline
                            with pipeline.connect(PYRO_COMM_TIMEOUT) as pipeline:
                                pipeline.notify_latest_frame(INSTRUMENT_ARM, LATEST_FRAME_PATH)
                        except Exception as e:
                            print('save thread: failed to notify latest frame with error ' + str(e))
                            observatory.log.error(self._log_table, 'Failed to notify pipeline (' \
                                                  + str(e) + ')')

                        # Compressing the frame can take a surprising amount of time (~10 sec!), so
                        # we save uncompressed, and run a compression pass at the end of the night.
                        if self._output_save_to_disk:
                            filename = self._output_frame_prefix + \
                                '-{:04d}.fits'.format(self._output_frame_number)
                            path = str(self._output_directory / filename)
                            shutil.copy(LATEST_FRAME_PATH, path)
                            observatory.log.info(self._log_table, 'Saved frame ' + filename)
                            self._output_frame_number += 1

                            try:
                                pipeline = observatory.daemons.onemetre_pipeline
                                with pipeline.connect(PYRO_COMM_TIMEOUT) as pipeline:
                                    pipeline.notify_saved_frame(INSTRUMENT_ARM, path)
                            except Exception as e:
                                print('save thread: failed to notify frame with error ' + str(e))
                                observatory.log.error(self._log_table,
                                                      'Failed to notify pipeline (' + str(e) + ')')
                    except Exception as e:
                        print('save thread: swallowing error ' + str(e))
                        observatory.log.error(self._log_table, 'Failed to save frame (' \
                                                  + str(e) + ')')
                    # Update previews
                    # Enumerate over a copy so we can remove dead servers from the original
                    if len(self._ds9_preview_addresses) > 0:
                        title_text = '{}s @ {} {}'.format(
                            float(self._exposure_time),
                            hdu.header['DATE-OBS'],
                            '[SAVED]' if self._output_save_to_disk else '[NOT SAVED]')

                        hdu.header['OBJECT'] = title_text
                        hdulist = fits.HDUList([hdu])
                        self.__update_previews(hdulist)
                except Exception as e:
                    print('save thread: swallowing error ' + str(e))
                    observatory.log.error(self._log_table, 'Failed to update frame previews (' \
                                          + str(e) + ')')

    def __update_previews(self, hdulist=None, xpa_messages=None, unregister_on_error=True):
        """Update registered preview clients with new data
           if hdulist is non-None the frame will be updated
           any xpa_messages will then be sent vertabim"""
        with self._preview_lock:
            for address in self._ds9_preview_addresses[:]:
                try:
                    p = pyds9.DS9(address, start=False, wait=1)
                    if hdulist is not None:
                        p.set_pyfits(hdulist)
                    if xpa_messages is not None:
                        for message in xpa_messages:
                            if isinstance(message, tuple):
                                p.set(message[0], message[1])
                            else:
                                p.set(message)
                except Exception as e:
                    if unregister_on_error:
                        self._ds9_preview_addresses.remove(address)
                        print('save thread: unregistering preview {}: {}'.format(
                            address, e))

    def __telescope_frame_headers(self):
        """Returns a dictionary of the telescope-related fits frame headers"""
        h = [
            (None, None, None),
            ('COMMENT', ' ---          TELESCOPE INFORMATION          --- ', ''),
        ]

        try:
            with observatory.daemons.onemetre_telescope.connect(PYRO_COMM_TIMEOUT) as teld:
                t = teld.report_status()
                h.append(('TELSWVER', t['software_version'], 'TCS server software version'))
                h.append(('TELSTATE', t['state_label'], 'telescope status'))
                if t['state'] != 0:
                    harad = t['lst'] - t['ra']
                    while harad > math.pi:
                        harad -= 2*math.pi
                    while harad < -math.pi:
                        harad += 2*math.pi

                    ra = helpers.sexagesimal(t['ra'] * 12 / math.pi)
                    h.append(('TELRA', ra, 'telescope nominal J2000 RA'))
                    dec = helpers.sexagesimal(math.degrees(t['dec']))
                    h.append(('TELDEC', dec, 'telescope nominal J2000 Dec'))
                    ha = helpers.sexagesimal(harad * 12 / math.pi)
                    h.append(('TELHA', ha, 'telescope nominal HA'))
                    rad = round(math.degrees(t['ra']), 3)
                    h.append(('TELRAD', rad, '[deg] telescope nominal J2000 RA'))
                    decd = round(math.degrees(t['dec']), 3)
                    h.append(('TELDECD', decd, '[deg] telescope nominal J2000 Dec'))
                    had = round(math.degrees(harad), 3)
                    h.append(('TELHAD', had, '[deg] telescope nominal HA'))
                    altd = round(math.degrees(t['alt']), 3)
                    h.append(('ALTITUDE', altd, '[deg] telescope altitude'))
                    azd = round(math.degrees(t['az']), 3)
                    h.append(('AZIMUTH', azd, '[deg] telescope azimuth'))
                    h.append(('TELFOCUS', t['telescope_focus_um'], '[um] telescope nominal focus'))

                if 'site_latitude' in t:
                    lat = helpers.sexagesimal(math.degrees(t['site_latitude']))
                    h.append(('SITELAT', lat, 'telescope latitude (north)'))
                    lon = helpers.sexagesimal(math.degrees(t['site_longitude']))
                    h.append(('SITELONG', lon, 'telescope longitude (east)'))
                    elevation = round(t['site_elevation'], 1)
                    h.append(('SITEELEV', elevation, '[m] telescope elevation'))
        except Exception as e:
            observatory.log.error(self._log_table, 'Failed to query telescope metadata (' \
                                  + str(e) + ')')

        return h

    def __camera_frame_headers(self):
        """Returns a dictionary of the camera-related fits frame headers"""
        rspd = self._horizontal_shift_speeds[self._horizontal_shift_speed_index]
        shutter = 'AUTO' if self._shutter_enabled else  'CLOSED'

        filename = ''
        if self._output_save_to_disk:
            filename = self._output_frame_prefix + \
                '-{:04d}.fits'.format(self._output_frame_number)

        return [
            (None, None, None),
            ('COMMENT', ' ---           CAMERA INFORMATION            --- ', ''),
            ('CAMSWVER', SOFTWARE_VERSION, 'camera server software version'),
            ('CAMERA', self._camera_model + ' ({})'.format(self._camera_serial),
             'camera model and serial number'),
            ('INSTRARM', INSTRUMENT_ARM, 'red or blue arm of the instrument'),
            ('FILTER', ARM_FILTER, 'filter installed in instrument arm'),
            ('CCD-TEMP', round(self._temperature, 2), '[deg c] CCD temperature at end of exposure'),
            ('SET-TEMP', self._target_temperature, '[deg c] CCD temperature set point'),
            ('TEMP-LCK', self._temperature_locked, 'CCD temperature is locked to set point'),
            ('CCD-XBIN', self._geometry_bin_x, '[px] x binning'),
            ('CCD-YBIN', self._geometry_bin_y, '[px] y binning'),
            ('CCD-WIND', '[{}:{},{}:{}]'.format(
                self._geometry_x, self._geometry_x + self._geometry_width - 1,
                self._geometry_y, self._geometry_y + self._geometry_height - 1),
             '[x1:x2,y1:y2] readout region (detector coords)'),
            ('CCD-GAIN', self._gains[self._gain_index], '[e-/DN] nominal readout gain'),
            ('CCD-RSPD', rspd, '[MHz] CCD readout speed'),
            ('SHUTTER', shutter, 'shutter mode'),
            ('IMAG-RGN', '[{}:{},{}:{}]'.format(
                self._geometry_image_x1, self._geometry_image_x2,
                self._geometry_image_y1, self._geometry_image_y2),
             '[x1:x2,y1:y2] image region (image coords)'),
            ('FILESAVE', self._output_save_to_disk, 'Image has been archived to disk'),
            ('FILENAME', filename, 'Archived image name')
        ]

    def __environment_frame_headers(self):
        """Returns a dictionary of the environment-related fits frame headers"""
        h = [
            (None, None, None),
            ('COMMENT', ' ---         ENVIRONMENT INFORMATION         --- ', ''),
        ]

        try:
            with observatory.daemons.onemetre_vaisala.connect(PYRO_COMM_TIMEOUT) as vaisala:
                v = vaisala.last_measurement()
                if v is not None:
                    h.append(('VSWVER', v['software_version'], 'vaisala server software version'))
                if v is not None and v['wind_speed_valid']:
                    h.append(('VWINDSPD', v['wind_speed'], '[km/h] vaisala wind speed'))
                if v is not None and v['wind_direction_valid']:
                    h.append(('VWINDDIR', v['wind_direction'], '[deg] vaisala wind direction'))
                if v is not None and v['temperature_valid']:
                    h.append(('VEXTTEMP', v['temperature'], '[deg c] vaisala external temperature'))
                if v is not None and v['relative_humidity_valid']:
                    h.append(('VEXTHUMD', v['relative_humidity'], '[%] vaisala external humidity'))
                if v is not None and v['pressure_valid']:
                    h.append(('VPRESSUR', v['pressure'], '[hPa] vaisala air pressure'))
        except Exception as e:
            observatory.log.error(self._log_table, 'Failed to query vaisala metadata (' \
                                  + str(e) + ')')
        try:
            with observatory.daemons.onemetre_roomalert.connect(PYRO_COMM_TIMEOUT) as roomalert:
                r = roomalert.last_measurement()
                if r is not None:
                    h.append(('RASWVER', r['software_version'],
                              'room alert server software version'))
                    h.append(('DOMETEMP', r['internal_temp'], '[deg c] dome temperature'))
                    h.append(('DOMEHUMD', r['internal_humidity'], '[%] dome humidity'))
                    h.append(('TRUSTEMP', r['truss_temp'], '[deg c] truss temperature'))
        except Exception as e:
            observatory.log.error(self._log_table, 'Failed to query roomalert metadata (' \
                                  + str(e) + ')')

        try:
            with observatory.daemons.superwasp_log.connect(PYRO_COMM_TIMEOUT) as superwasp:
                s = superwasp.last_measurement()
                if s is not None:
                    h.append(('SWSWVER', s['software_version'],
                              'superwasp monitor server software version'))
                    h.append(('SKYTEMP', s['sky_temp'], '[deg c] sky temperature'))
                    h.append(('DEWPDELT', s['dew_point_delta'],
                              '[deg c] temperature above dew point'))
        except Exception as e:
            observatory.log.error(self._log_table, 'Failed to query superwasp metadata (' \
                                  + str(e) + ')')

        return h

    def __set_target_temperature_and_cooler(self, target_temperature, cooler_enabled):
        """Set the camera temperature and cooler configuration"""
        self._target_temperature = target_temperature
        with self._driver_lock:
            if self._driver is None:
                return False

            status = self._driver.SetTemperature(c_int(target_temperature))
            if status != AndorStatus.Success:
                return False

            if cooler_enabled:
                status = self._driver.CoolerON()
            else:
                status = self._driver.CoolerOFF()

            return status == AndorStatus.Success

    def __run_exposure_sequence(self):
        """Worker thread that acquires frames and their times.
           Tagged frames are pushed to the acquisition queue
           for further processing on another thread"""
        try:
            pixel_count = (self._geometry_width // self._geometry_bin_x) * \
                          (self._geometry_height // self._geometry_bin_y)
            while not self._stop_acquisition:
                framedata = bytearray(pixel_count * 2)

                with self._driver_lock:
                    start_time = datetime.datetime.utcnow()
                    status = self._driver.StartAcquisition()
                if status != AndorStatus.Success:
                    print('exposure sequence: failed to start acquisition with status ' + \
                          str(status))
                    observatory.log.error(self._log_table, 'Failed to start exposure sequence (' \
                                  + str(status) + ')')
                    break

                self._sequence_exposure_start_time = start_time

                # TODO: thread safety: do we need the driver lock?
                status = self._driver.WaitForAcquisition()
                if status != AndorStatus.Success:
                    print('exposure sequence: waiting failed with status ' + str(status))
                    observatory.log.error(self._log_table, 'Failed to wait for acquisition (' \
                                  + str(status) + ')')
                    break

                end_time = datetime.datetime.utcnow()
                cdata = (c_uint16 * pixel_count).from_buffer(framedata)
                status = self._driver.GetAcquiredData16(byref(cdata), c_long(pixel_count))
                if status != AndorStatus.Success:
                    print('exposure sequence: failed to get acquired data with status ' + \
                          str(status))
                    observatory.log.error(self._log_table, 'Failed to query frame data (' \
                                  + str(status) + ')')
                    break

                # Build metadata list
                header = [
                    (None, None, None),
                    ('COMMENT', ' ---                DATE/TIME                --- ', ''),
                    ('DATE-OBS', start_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                     '[UTC] date that exposure was triggered'),
                    ('DATE-END', end_time.strftime('%Y-%m-%dT%H:%M:%S.%f')[:-3],
                     '[UTC] date that data was received by PC'),
                    ('EXPTIME', float(self._exposure_time), '[s] exposure time'),
                    ('TIME-SRC', 'NTP', 'times are measured using NTP-synced PC clock'),
                ]

                # Query additional metadata
                # The next acquisition is blocked on these queries, so make sure they are fast!
                header.extend(self.__telescope_frame_headers())
                header.extend(self.__camera_frame_headers())
                header.extend(self.__environment_frame_headers())

                # Pass frame to processing thread
                self._acquisition_queue.put((framedata, header))
                with self._acquisition_condition:
                    self._acquisition_condition.notify()

                # Continue exposure sequence?
                self._sequence_frame_count += 1
                if self._sequence_frame_limit > 0 and \
                        self._sequence_frame_count >= self._sequence_frame_limit:
                    self._stop_acquisition = True
        finally:
            print('exposure sequence: complete')
            observatory.log.info(self._log_table, 'Exposure sequence complete')
            self._status = CameraStatus.Idle

    @Pyro4.expose
    def set_target_temperature(self, temperature, enable_cooler=None):
        """Set the target camera temperature.  Optionally enable or disable cooling"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if temperature < self._min_temperature or temperature > self._max_temperature:
                return CommandStatus.TemperatureOutsideLimits

            if enable_cooler is None:
                enable_cooler = self._cooler_enabled

            if not self.__set_target_temperature_and_cooler(temperature, enable_cooler):
                return CommandStatus.Failed

            observatory.log.info(self._log_table, 'Target temperature set to ' + str(temperature))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def enable_cooler(self, enabled):
        """Enable or disable active cooling"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if not self.__set_target_temperature_and_cooler(self._target_temperature, enabled):
                return CommandStatus.Failed

            observatory.log.info(self._log_table, 'Cooler ' \
                                 + ('enabled' if enabled else 'disabled'))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def report_status(self):
        """Returns a dictionary containing the current camera state"""
        data = {'state': self._status}
        if self._status != CameraStatus.Disabled:
            shift_mhz = self._horizontal_shift_speeds[self._horizontal_shift_speed_index]
            gain_factor = self._gains[self._gain_index]
            next_filename = self._output_frame_prefix + \
                '-{:04d}.fits'.format(self._output_frame_number)

            # Estimate the current frame progress based on the time delta
            progress = 0
            if self._status == CameraStatus.Acquiring:
                delta = datetime.datetime.utcnow() - self._sequence_exposure_start_time
                progress = delta.total_seconds()
                if progress > self._exposure_time:
                    data['state'] = CameraStatus.Reading
                    progress = 0

            data.update({
                'temperature': self._temperature,
                'temperature_locked': self._temperature_locked,
                'target_temperature': self._target_temperature,
                'cooler_enabled': self._cooler_enabled,
                'shutter_enabled': self._shutter_enabled,
                'exposure_time': self._exposure_time,
                'exposure_progress': progress,
                'gain_index': self._gain_index,
                'gain_factor': gain_factor,
                'horizontal_shift_speed_index': self._horizontal_shift_speed_index,
                'horizontal_shift_speed_mhz': shift_mhz,
                'geometry_bin_x': self._geometry_bin_x,
                'geometry_bin_y': self._geometry_bin_y,
                'geometry_x': self._geometry_x,
                'geometry_y': self._geometry_y,
                'geometry_width': self._geometry_width,
                'geometry_height': self._geometry_height,
                'sequence_frame_limit': self._sequence_frame_limit,
                'sequence_frame_count': self._sequence_frame_count,
                'frame_directory': str(self._output_directory),
                'next_filename': next_filename,
                'save_enabled': self._output_save_to_disk
            })
        return data

    # pylint: disable=too-many-return-statements
    # pylint: disable=too-many-branches
    # pylint: disable=too-many-statements
    # pylint: disable=too-many-locals
    @Pyro4.expose
    def initialize(self):
        """Connects to the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status != CameraStatus.Disabled:
                return CommandStatus.CameraNotUninitialized

            self._status = CameraStatus.Initializing
            print('initializing driver')
            driver = CDLL('libandor.so')
            try:
                num_cameras = c_int32()
                status = driver.GetAvailableCameras(byref(num_cameras))
                if status != AndorStatus.Success or num_cameras.value == 0:
                    return CommandStatus.CameraNotFound

                # Enumerate cameras to find target
                handle = c_int32()
                model = create_string_buffer(4096)
                serial = c_int()
                found = False
                print('{} cameras available'.format(num_cameras.value))
                for i in range(num_cameras.value):
                    status = driver.GetCameraHandle(c_int32(i), byref(handle))
                    if status != AndorStatus.Success:
                        print('failed to query handle for camera {}: status {}'.format(i, status))
                        continue

                    status = driver.SetCurrentCamera(handle)
                    if status != AndorStatus.Success:
                        print('failed to select camera {}: status {}'.format(i, status))
                        continue

                    status = driver.Initialize('/usr/local/etc/andor'.encode('ascii'))
                    if status != AndorStatus.Success:
                        print('failed to initialize camera {}: status {}'.format(i, status))
                        continue

                    status = driver.GetHeadModel(model)
                    if status != AndorStatus.Success:
                        print('failed to query camera {} model: status {}'.format(i, status))
                        driver.ShutDown()
                        continue

                    status = driver.GetCameraSerialNumber(byref(serial))
                    if status != AndorStatus.Success:
                        print('failed to query camera {} serial: status {}'.format(i, status))
                        driver.ShutDown()
                        continue

                    print('camera {} is {} ({})'.format(i, model.value.decode('ascii'),
                                                        serial.value))

                    if serial.value == CAMERA_SERIAL:
                        found = True
                        break
                    else:
                        driver.ShutDown()

                if not found:
                    driver = None
                    print('camera with serial {} was not found'.format(CAMERA_SERIAL))
                    return CommandStatus.CameraNotFound

                # Query cooler temperature limits
                min_temp = c_int(self._min_temperature)
                max_temp = c_int(self._max_temperature)
                status = driver.GetTemperatureRange(byref(min_temp), byref(max_temp))
                if status != AndorStatus.Success:
                    print('failed to query camera temperature limits with status ' + str(status))
                    return CommandStatus.Failed

                # Query detector size
                width = c_int(self._ccd_width)
                height = c_int(self._ccd_height)
                status = driver.GetDetector(byref(width), byref(height))
                if status != AndorStatus.Success:
                    print('failed to query detector size with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default shutter
                shutter = c_int(0 if self._shutter_enabled else 2)
                status = driver.SetShutter(c_int(1), shutter, c_int(50), c_int(50))
                if status != AndorStatus.Success:
                    print('failed to set shutter closed with status {}'.format(status))
                    return CommandStatus.Failed

                # Configure standard 2D image readout
                status = driver.SetReadMode(c_int(4))
                if status != AndorStatus.Success:
                    print('failed to set image readout mode with status {}'.format(status))
                    return CommandStatus.Failed

                # Camera does not support hardware timing, so we are forced to do individual
                # exposures via software
                status = driver.SetAcquisitionMode(c_int(1))
                if status != AndorStatus.Success:
                    print('failed to set acquisition mode with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default exposure time
                status = driver.SetExposureTime(c_float(self._exposure_time))
                if status != AndorStatus.Success:
                    print('failed to set default exposure time with status {}'.format(status))
                    return CommandStatus.Failed

                # Query gains
                gain_count = c_int(0)
                status = driver.GetNumberPreAmpGains(byref(gain_count))
                if status != AndorStatus.Success:
                    print('failed to query gain count with status ' + str(status))
                    return CommandStatus.Failed

                gains = []
                gain = c_float(0)
                for i in range(gain_count.value):
                    status = driver.GetPreAmpGain(c_int(i), byref(gain))
                    if status != AndorStatus.Success:
                        print('failed to query gain for index {} with status {}'.format(i, status))
                        return CommandStatus.Failed
                    gains.append(gain.value)

                # Set default gain index
                status = driver.SetPreAmpGain(c_int(self._gain_index))
                if status != AndorStatus.Success:
                    print('failed to set default gain index with status {}'.format(status))
                    return CommandStatus.Failed

                # Query horizontal shift speeds
                # Assumes that there is only one readout channel, and no electron multiplication
                shift_count = c_int(0)
                status = driver.GetNumberHSSpeeds(c_int(0), c_int(0), byref(shift_count))
                if status != AndorStatus.Success:
                    print('failed to query horizontal shift speed count with status ' + \
                          str(status))
                    return CommandStatus.Failed

                speeds = []
                speed = c_float(0)
                for i in range(shift_count.value):
                    status = driver.GetHSSpeed(c_int(0), c_int(0), c_int(i), byref(speed))
                    if status != AndorStatus.Success:
                        print('failed to query horizontal shift speed for index ' + \
                            '{} with status {}'.format(i, status))
                        return CommandStatus.Failed
                    speeds.append(speed.value)

                # Set default horizontal shift index
                status = driver.SetHSSpeed(c_int(0), c_int(self._horizontal_shift_speed_index))
                if status != AndorStatus.Success:
                    print('failed to set default horizontal shift speed index with status ' + \
                          str(status))
                    return CommandStatus.Failed

                # Set default readout geometry
                status = driver.SetImage(c_int(1), c_int(1),
                                         c_int(1), c_int(width.value),
                                         c_int(1), c_int(height.value))
                if status != AndorStatus.Success:
                    print('failed to set default readout geometry with status {}'.format(status))
                    return CommandStatus.Failed

                # Set default temperature
                status = driver.SetTemperature(c_int(self._target_temperature))
                if status != AndorStatus.Success:
                    print('failed to set default target temperature with status {}'.format(status))
                    return CommandStatus.Failed

                status = driver.CoolerON()
                if status != AndorStatus.Success:
                    print('failed to enable cooling with status {}'.format(status))
                    return CommandStatus.Failed

                with self._driver_lock:
                    self._driver = driver
                    self._camera_model = model.value.decode('ascii')
                    self._camera_serial = serial.value
                    self._min_temperature = min_temp.value
                    self._max_temperature = max_temp.value
                    self._ccd_width = width.value
                    self._ccd_height = height.value
                    self._geometry_bin_x = 1
                    self._geometry_bin_y = 1
                    self._geometry_x = 1
                    self._geometry_y = 1
                    self._geometry_width = self._ccd_width
                    self._geometry_height = self._ccd_height

                    self._geometry_image_x1 = 1 + PRESCAN_COLUMNS
                    self._geometry_image_x2 = self._ccd_width - POSTSCAN_COLUMNS
                    self._geometry_image_y1 = 1
                    self._geometry_image_y2 = self._ccd_height

                    self._gains = gains
                    self._horizontal_shift_speeds = speeds
                    self._status = CameraStatus.Idle
                    print('camera {} ({}) initalized'.format(self._camera_model,
                                                             self._camera_serial))

                return CommandStatus.Succeeded
            finally:
                # Clean up on failure
                if self._status != CameraStatus.Idle:
                    if driver is not None:
                        driver.ShutDown()
                    self._status = CameraStatus.Disabled
                    observatory.log.error(self._log_table, 'Failed to initialize camera')
                else:
                    observatory.log.info(self._log_table, 'Initialized camera')
    # pylint: enable=too-many-return-statements
    # pylint: enable=too-many-branches
    # pylint: enable=too-many-statements
    # pylint: enable=too-many-locals

    @Pyro4.expose
    def set_output_frame_directory(self, directory):
        """Sets the output frame directory"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled

            # Check that the directory exists and is writable
            try:
                path = pathlib.Path(directory).resolve()
                testfile = tempfile.TemporaryFile(dir=str(path))
                self._output_directory = path
                testfile.close()
            except Exception:
                return CommandStatus.DirectoryNotWritable

            observatory.log.info(self._log_table, 'Frame directory set to ' + str(path))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_output_frame_prefix(self, prefix):
        """Sets the output frame prefix"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled
            self._output_frame_prefix = prefix

            observatory.log.info(self._log_table, 'Frame prefix set to ' + prefix)
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_save(self, enabled):
        """Enable or disable saving to disk"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._output_save_to_disk = enabled
            observatory.log.info(self._log_table, 'Frame saving ' \
                                 + ('enabled' if enabled else 'disabled'))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def register_preview(self, address):
        """Register a ds9 window for previews"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            self._ds9_preview_addresses.append(address)

            return CommandStatus.Succeeded

    @Pyro4.expose
    def update_previews(self, xpa_commands):
        """Send xpa commands to active previews"""
        # Errors may be caused by the command, so don't unregister on failure
        self.__update_previews(None, xpa_commands, False)
        return CommandStatus.Succeeded

    @Pyro4.expose
    def set_output_frame_number(self, number):
        """Sets the output frame number"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            # TODO: Only allow if saving is disabled
            self._output_frame_number = int(number)

            observatory.log.info(self._log_table, 'Frame number set to ' + str(number))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_shutter(self, enabled):
        """Enable or disable the shutter"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                value = c_int(0 if enabled else 2)
                status = self._driver.SetShutter(c_int(1), value, c_int(50), c_int(50))
                if status != AndorStatus.Success:
                    mode = 'auto' if enabled else 'closed'
                    print('failed to set shutter {} with status {}'.format(mode, status))
                    return CommandStatus.Failed
                self._shutter_enabled = enabled

            observatory.log.info(self._log_table, 'Shutter set to ' \
                                 + 'auto' if enabled else 'closed')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_gain(self, gain_index):
        """Set the preamplifier gain index"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetPreAmpGain(c_int(gain_index))
                if status == AndorStatus.DrvP1Invalid:
                    return CommandStatus.InvalidGainIndex
                if status != AndorStatus.Success:
                    print('failed to set gain {} with status {}'.format(gain_index, status))
                    return CommandStatus.Failed
                self._gain_index = gain_index

            observatory.log.info(self._log_table, 'Gain index set to ' + str(gain_index))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_horizontal_shift(self, shift_speed_index):
        """Set the horizontal shift speed index"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetHSSpeed(c_int(0), c_int(shift_speed_index))
                if status == AndorStatus.DrvP2Invalid:
                    return CommandStatus.InvalidShiftSpeedIndex
                if status != AndorStatus.Success:
                    print('failed to set horizontal shift {} with status {}'.format(
                        shift_speed_index, status))
                    return CommandStatus.Failed
                self._horizontal_shift_speed_index = shift_speed_index

            observatory.log.info(self._log_table, 'Readout speed index set to ' \
                                 + str(shift_speed_index))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_exposure(self, seconds):
        """Set the exposure time in seconds"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            with self._driver_lock:
                status = self._driver.SetExposureTime(c_float(seconds))
                if status != AndorStatus.Success:
                    print('failed to set exposure ({}s) with status {}'.format(seconds, status))
                    return CommandStatus.Failed
                self._exposure_time = seconds

            observatory.log.info(self._log_table, 'Exposure time set to ' + str(seconds) + 's')
            return CommandStatus.Succeeded

    def __set_ccd_geometry(self, bin_x, bin_y, x, y, width, height):
        """Set the exposure readout geometry."""
        with self._driver_lock:
            status = self._driver.SetImage(c_int(bin_x), c_int(bin_y),
                                           c_int(x), c_int(x + width - 1),
                                           c_int(y), c_int(y + height - 1))
            if status != AndorStatus.Success:
                print('failed to set geometry [{},{}]({}, {}, {}, {}) with status {}'.format(
                    bin_x, bin_y, x, y, width, height, status))
                return False

            self._geometry_bin_x = bin_x
            self._geometry_bin_y = bin_y
            self._geometry_x = x
            self._geometry_y = y
            self._geometry_width = width
            self._geometry_height = height

            # Round prescan and postscan up to nearest superpixel to avoid bleeding
            prescan = int((PRESCAN_COLUMNS + bin_x - 1) / bin_x)
            postscan = int((POSTSCAN_COLUMNS + bin_x - 1) / bin_x)

            # Work out how much pre/post scan columns are left in the requested window
            window_x = int((x - 1) / bin_x)
            self._geometry_image_x1 = 1 + max(prescan, int((x - 1) / bin_x)) - window_x
            self._geometry_image_x2 = min(int(self._ccd_width / bin_x) - postscan, \
                int((x + width - 1) / bin_x)) - window_x
            self._geometry_image_y1 = 1 + int((y - 1) / bin_y)
            self._geometry_image_y2 = int(height / bin_y)

            # Window is completely in the overscan
            if self._geometry_image_x2 <= self._geometry_image_x1:
                self._geometry_image_x1 = self._geometry_image_x2 = 0
                self._geometry_image_y1 = self._geometry_image_y2 = 0

        return True

    @Pyro4.expose
    def set_binning(self, bin_x, bin_y):
        """Sets the CCD readout binning (both x and y)"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if not self.__set_ccd_geometry(bin_x, bin_y, self._geometry_x, self._geometry_y,
                                           self._geometry_width, self._geometry_height):
                return CommandStatus.BinningIncompatibleWithWindow

            observatory.log.info(self._log_table, 'Binning set to ' + str(bin_x) + 'x' + str(bin_y))
            return CommandStatus.Succeeded

    @Pyro4.expose
    def set_window(self, x, y, width, height):
        """Sets the CCD readout window in unbinned (hardware) pixels"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            if x < 1 or y < 1 or x + width - 1 > self._ccd_width or \
                    y + height - 1 > self._ccd_height:
                return CommandStatus.WindowOutsideCCD

            if not self.__set_ccd_geometry(self._geometry_bin_x, self._geometry_bin_x, x, y,
                                           width, height):
                return CommandStatus.WindowIncompatibleWithBinning

            region = '[' + str(x) + ':' + str(x + width - 1) + ',' + str(y) + ':' \
                     + str(y + height - 1) + ']'
            observatory.log.info(self._log_table, 'Window set to ' + region)
            return CommandStatus.Succeeded

    @Pyro4.expose
    def shutdown(self):
        """Disconnects from the camera driver"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            # Complete the current exposure
            if self._acquisition_thread is not None:
                with self._driver_lock:
                    self._driver.AbortAcquisition()

                print('shutdown: waiting for acquisition to complete')
                self._stop_acquisition = True
                self._acquisition_thread.join()

            with self._driver_lock:
                print('shutdown: disconnecting driver')
                self._driver.ShutDown()
                self._driver = None

            observatory.log.info(self._log_table, 'Shutdown camera')
            return CommandStatus.Succeeded

    @Pyro4.expose
    def start_sequence(self, count):
        """Starts an exposure sequence with a set number of frames, or 0 to run until stopped"""
        with TryLock(self._command_lock) as success:
            if not success:
                return CommandStatus.Blocked

            if self._status == CameraStatus.Disabled:
                return CommandStatus.CameraNotInitialized

            if self._status != CameraStatus.Idle:
                return CommandStatus.CameraNotIdle

            print('starting exposure sequence')
            count_msg = 'until stopped'
            if count == 1:
                count_msg = '1 frame'
            elif count > 1:
                count_msg = str(count) + ' frames'

            observatory.log.info(self._log_table, 'Starting exposure sequence (' + count_msg + ')')
            self._sequence_frame_limit = count
            self._sequence_frame_count = 0
            self._stop_acquisition = False
            self._acquisition_thread = threading.Thread(target=self.__run_exposure_sequence)
            self._acquisition_thread.daemon = False
            self._acquisition_thread.start()
            self._status = CameraStatus.Acquiring

            return CommandStatus.Succeeded

    @Pyro4.expose
    def stop_sequence(self):
        """Stops any active exposure sequence"""
        if self._status == CameraStatus.Disabled:
            return CommandStatus.CameraNotInitialized

        if self._status != CameraStatus.Acquiring:
            return CommandStatus.CameraNotAcquiring

        self._status = CameraStatus.Aborting
        print('aborting exposure sequence')
        observatory.log.info(self._log_table, 'Aborting exposure sequence')
        with self._driver_lock:
            self._driver.AbortAcquisition()

        self._sequence_frame_count = 0
        self._stop_acquisition = True

        return CommandStatus.Succeeded

if __name__ == '__main__':
    CAMD_DAEMON.launch(CameraDaemon(LOG_TABLE))

